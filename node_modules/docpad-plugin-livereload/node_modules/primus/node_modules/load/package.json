{
  "name": "load",
  "version": "0.1.2",
  "description": "Load plain JavaScript files that don't use module patterns directly in node.",
  "main": "index.js",
  "scripts": {
    "test": "node test/index.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/3rd-Eden/load.git"
  },
  "keywords": [
    "load",
    "require",
    "module",
    "import",
    "export",
    "amd",
    "browser",
    "exports"
  ],
  "author": {
    "name": "Arnout Kazemier"
  },
  "license": "MIT",
  "devDependencies": {
    "pre-commit": "0.0.x"
  },
  "readme": "# load\n\n[![Build Status](https://travis-ci.org/3rd-Eden/load.png)](https://travis-ci.org/3rd-Eden/load)\n[![NPM version](https://badge.fury.io/js/load.png)](http://badge.fury.io/js/load)\n\nBecause fuck dedicated module patterns, module loaders, compilers and other kind\nof pointless code bloat that requires me to wrap my client-side JavaScript for\nserver usage.\n\nPeople need to understand that the Node.js module system is nothing more then a\n`vm` that reads our a pre-defined `module` variable. We don't need to be stuck\nin this pattern, we can just get all the globals that are introduced while we\nload the script and tada, we're running the snippet on the server.\n\n## Installation\n\nLoad is available in `npm` so you can install it by running:\n\n```\nnpm --save load\n```\n\n## API\n\n```js\nvar load = require('load');\n\n// file.js contents:\n//\n// function test() { return 'test' };\n//\n\n// Only one global exported, automatically exposes the function by default.\nvar test = load('file.js');\n\n// file2.js contents:\n//\n// function test() {}\n// function test1() {}\n//\n\nvar library = load('file2');\nconsole.log(library.test);\nconsole.log(library.test1);\n\nvar moo = load.compiler('function cow() { console.log(\"moo\") }', 'moo.js');\nmoo(); // console.log('moo');\n\n// And that it.\n```\n\n## License\n\nMIT\n",
  "_id": "load@0.1.2",
  "dist": {
    "shasum": "e19846765b71be67ab54a093f0fe62b3b8f1a883"
  },
  "_from": "load@0.1.x"
}
